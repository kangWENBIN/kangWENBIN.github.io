<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>01_Qt | CodeingKang</title><meta name="keywords" content="Qt,C++"><meta name="author" content="小k"><meta name="copyright" content="小k"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Qt是一个跨平台的C++图形用户界面应用程序框架。它为应用程序开发者提供建立艺术级图形界面所需的所有功能。">
<meta property="og:type" content="article">
<meta property="og:title" content="01_Qt">
<meta property="og:url" content="http://example.com/2022/03/29/QtStudy/01day/index.html">
<meta property="og:site_name" content="CodeingKang">
<meta property="og:description" content="Qt是一个跨平台的C++图形用户界面应用程序框架。它为应用程序开发者提供建立艺术级图形界面所需的所有功能。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/Qt%E5%B0%81%E9%9D%A2.png">
<meta property="article:published_time" content="2022-03-29T02:00:00.000Z">
<meta property="article:modified_time" content="2022-03-30T14:45:03.584Z">
<meta property="article:author" content="小k">
<meta property="article:tag" content="Qt">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/Qt%E5%B0%81%E9%9D%A2.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/03/29/QtStudy/01day/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":150},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 小k","link":"链接: ","source":"来源: CodeingKang","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '01_Qt',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-30 22:45:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/Qt%E5%B0%81%E9%9D%A2.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">CodeingKang</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">01_Qt</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-29T02:00:00.000Z" title="发表于 2022-03-29 10:00:00">2022-03-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-30T14:45:03.584Z" title="更新于 2022-03-30 22:45:03">2022-03-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Qt/">Qt</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="01_Qt"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1、Qt的介绍"><a href="#1、Qt的介绍" class="headerlink" title="1、Qt的介绍"></a>1、Qt的介绍</h1><h3 id="1-1、-什么是Qt"><a href="#1-1、-什么是Qt" class="headerlink" title="1.1、 什么是Qt?"></a>1.1、 什么是Qt?</h3><p>Qt是一个跨平台的C++图形用户界面应用程序框架。它为应用程序开发者提供建立艺术级图形界面所需的所有功能。它是完全面向对象的，很容易扩展，并且允许真正的组件编程。</p>
<h3 id="1-2、Qt历史"><a href="#1-2、Qt历史" class="headerlink" title="1.2、Qt历史"></a>1.2、Qt历史</h3><ul>
<li>1991年 Qt最早由奇趣科技开发</li>
<li>1996年 进入商业领域，它也是目前流行的Linux桌面环境KDE的基础</li>
<li>2008年 奇趣科技被诺基亚公司收购，Qt称为诺基亚旗下的编程语言</li>
<li>2012年 Qt又被Digia公司收购</li>
<li>2014年4月 跨平台的集成开发环境QtCreator3.1.0发布，同年5月20日配发了Qt5.3正式版，至此Qt实现了对iOS、Android、WP等各平台的全面支持。<h3 id="1-3、支持平台"><a href="#1-3、支持平台" class="headerlink" title="1.3、支持平台"></a>1.3、支持平台</h3></li>
<li>Windows – XP、Vista、Win7、Win8、Win2008、Win10</li>
<li>Uinux&#x2F;X11 – Linux、Sun Solaris、HP-UX、Compaq Tru64 UNIX、IBM AIX、SGI IRIX、FreeBSD、BSD&#x2F;OS、和其他很多X11平台</li>
<li>Macintosh – Mac OS X</li>
<li>Embedded – 有帧缓冲支持的嵌入式Linux平台，Windows CE<h3 id="1-4、Qt版本"><a href="#1-4、Qt版本" class="headerlink" title="1.4、Qt版本"></a>1.4、Qt版本</h3>Qt按照不同的版本发行，分为商业版和开源版。</li>
<li>商业版<blockquote>
<p>为商业软件提供开发，他们提供传统商业软件发行版，并且提供在商业有效期内的免费升级和技术支持服务。</p>
</blockquote>
</li>
<li>开源的LGPL版本：<blockquote>
<p>为了开发自有而设计的开放源码软件，它提供了和商业版本同样的功能，在GNU通用公共许可下，它是免费的。</p>
</blockquote>
<h3 id="1-5、Qt的优点"><a href="#1-5、Qt的优点" class="headerlink" title="1.5、Qt的优点"></a>1.5、Qt的优点</h3></li>
<li>跨平台，几乎支持所有的平台；</li>
<li>接口简单，容易上手，学习QT框架对学习其他框架有参考意义；</li>
<li>一定程度上简化了内存回收机制；</li>
<li>开发效率高，能够快速的构建应用程序；</li>
<li>有很好的社区氛围，市场份额在缓慢上升；</li>
<li>可以进行嵌入式开发。<h1 id="2、Qt的安装步骤"><a href="#2、Qt的安装步骤" class="headerlink" title="2、Qt的安装步骤"></a>2、Qt的安装步骤</h1>安装步骤就省略了，网上安装教程一大把，安装过程也是傻瓜式的操作，下一步下一步即可。<h1 id="3、项目文件"><a href="#3、项目文件" class="headerlink" title="3、项目文件"></a>3、项目文件</h1><h3 id="3-1、使用向导创建项目"><a href="#3-1、使用向导创建项目" class="headerlink" title="3.1、使用向导创建项目"></a>3.1、使用向导创建项目</h3></li>
<li>打开Qt Creator 界面选择 New Project或者选择菜单栏 【欢迎】-【New Project】菜单项。<br><img src="https://gitee.com/kwb110/tuchuang/raw/master/001.png"></li>
<li>弹出New Project对话框，选择Qt Widgets Application。<br><img src="https://gitee.com/kwb110/tuchuang/raw/master/002.png"></li>
<li>选择【Choose】按钮，弹出如下对话框，名称可以起自己喜欢的项目名字，创建路径选择自己索要存储的路径，也可以设置为自己默认的项目路径，然后点击下一步。<br><img src="https://gitee.com/kwb110/tuchuang/raw/master/003.png"></li>
<li>选择编译套件。<br><img src="https://gitee.com/kwb110/tuchuang/raw/master/004.png"></li>
<li>向导会默认添加一个继承自CMainWindow的类，可以在此修改类的名字和基类。继续下一步。<br><img src="https://gitee.com/kwb110/tuchuang/raw/master/005.png" alt="01"></li>
<li>即可创建出一个Qt桌面程序。<br><img src="https://gitee.com/kwb110/tuchuang/raw/master/006.png"><h1 id="4、第一个Qt程序"><a href="#4、第一个Qt程序" class="headerlink" title="4、第一个Qt程序"></a>4、第一个Qt程序</h1>通过上面的步骤，其实我们已经得到了一个Qt程序。<br><img src="https://gitee.com/kwb110/tuchuang/raw/master/007.png"><br>我们先来看一下这个工程文件.pro文件。<br>在使用Qt向导生成的应用程序.pro文件格式如下：<br><img src="https://gitee.com/kwb110/tuchuang/raw/master/tree/fuyong.png"></li>
</ul>
<p><img src="https://gitee.com/kwb110/tuchuang/raw/master/sucai/zhuomianbizhi11.jpg"><br>QT       +&#x3D; core gui &#x2F;&#x2F;模块的名字</p>
<p>greaterThan(QT_MAJOR_VERSION, 4): QT +&#x3D; widgets</p>
<p>TARGET &#x3D; HelloQt &#x2F;&#x2F;应用程序名<br>TEMPLATE &#x3D; app &#x2F;&#x2F;生成的makefile的模板类型</p>
<p>&#x2F;&#x2F;源文件<br>SOURCES +&#x3D; <br>        main.cpp <br>        widget.cpp<br>&#x2F;&#x2F;头文件<br>HEADERS +&#x3D; <br>        widget.h<br>&#x2F;&#x2F;窗口设计文件<br>FORMS +&#x3D; <br>        widget.ui</p>
<hr>
<p>pro就是工程文件(project)，它是qmake自动生成的用于生产makefile的配置文件。.pro文件的写法如下：</p>
<ul>
<li>注释<br>从“#”开始，到这一行结束。</li>
<li>模板变量告诉qmake为这个应用程序生成哪种makefile。下面是可供使用的选择：TEMPLATE &#x3D; app</li>
<li>app -建立一个应用程序的makefile。这是默认值，所以如果模板没有被指定，这个将被使用。</li>
<li>lib - 建立一个库的makefile。</li>
<li>vcapp - 建立一个应用程序的VisualStudio项目文件。</li>
<li>vclib - 建立一个库的VisualStudio项目文件。</li>
<li>subdirs -这是一个特殊的模板，它可以创建一个能够进入特定目录并且为一个项目文件生成makefile并且为它调用make的makefile。</li>
<li>#指定生成的应用程序名：<br>TARGET &#x3D; QtDemo</li>
<li>#工程中包含的头文件<br>HEADERS +&#x3D; include&#x2F;painter.h</li>
<li>#工程中包含的.ui设计文件<br>FORMS +&#x3D; forms&#x2F;painter.ui</li>
<li>#工程中包含的源文件<br>SOURCES +&#x3D; sources&#x2F;main.cpp sources&#x2F;painter.cpp</li>
<li>#工程中包含的资源文件<br>RESOURCES +&#x3D; qrc&#x2F;painter.qrc</li>
<li>greaterThan(QT_MAJOR_VERSION, 4): QT +&#x3D; widgets<br>这条语句的含义是，如果QT_MAJOR_VERSION大于4（也就是当前使用的Qt5及更高版本）需要增加widgets模块。如果项目仅需支持Qt5，也可以直接添加“QT +&#x3D; widgets”一句。不过为了保持代码兼容，最好还是按照QtCreator生成的语句编写。</li>
<li>#配置信息<br>CONFIG用来告诉qmake关于应用程序的配置信息。<br>CONFIG +&#x3D; c++11    &#x2F;&#x2F;使用c++11的特性<br>在这里使用“+&#x3D;”，是因为我们添加我们的配置选项到任何一个已经存在中。这样做比使用“&#x3D;”那样替换已经指定的所有选项更安全。</li>
</ul>
<h3 id="4-1、一个最简单的Qt应用程序"><a href="#4-1、一个最简单的Qt应用程序" class="headerlink" title="4.1、一个最简单的Qt应用程序"></a>4.1、一个最简单的Qt应用程序</h3><p>#include “widget.h”</p>
<p>&#x2F;&#x2F;QApplication 应用程序类<br>&#x2F;&#x2F;Qt头文件没有.h<br>&#x2F;&#x2F;头文件和类名一样<br>#include <QApplication></p>
<p>int main(int argc, char *argv[])<br>{<br>    &#x2F;&#x2F;有且只有一个应用程序类<br>    QApplication a(argc, argv);</p>
<pre><code>//widget继承于QWidget，QWidget是一个窗口基类
//所以widget也是窗口类
//w就是一个窗口
Widget w;
//窗口创建时隐藏的，需要人为显示
w.show();

//a.exec()让程序一直执行，等待用户操作，等待事件发生
return a.exec();
</code></pre>
<p>}</p>
<h1 id="5、窗口（控件）"><a href="#5、窗口（控件）" class="headerlink" title="5、窗口（控件）"></a>5、窗口（控件）</h1><h3 id="5-1、QPushButtn"><a href="#5-1、QPushButtn" class="headerlink" title="5.1、QPushButtn"></a>5.1、QPushButtn</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;widget.h&quot;</span><br><span class="line">#include &quot;ui_widget.h&quot;</span><br><span class="line">#include &lt;QPushButton&gt;</span><br><span class="line"></span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(new Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    QPushButton *btn = new QPushButton(this);</span><br><span class="line">    btn-&gt;setText(&quot;I am a btn&quot;); //按钮的内容</span><br><span class="line">    btn-&gt;show();</span><br><span class="line">    ui-&gt;setupUi(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~Widget()</span><br><span class="line">&#123;</span><br><span class="line">    delete ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行：<br><img src="https://gitee.com/kwb110/tuchuang/raw/master/008.png"><br>注意：<br>需要给按钮指定父对象，如果不指定父对象，那么对象和对象（窗口和窗口）没有关系，是没有关系的，a指定b为它的父对象，a放在b的上面。指定父对象有两种方式：</p>
<ul>
<li>setParent</li>
<li>通过构造函数传参<br>指定父对象，只需要父对象显示，上面的子对象自动显示。<h1 id="6、信号和槽"><a href="#6、信号和槽" class="headerlink" title="6、信号和槽"></a>6、信号和槽</h1>信号槽是 Qt 框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式。当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。（这里提一句，Qt 的信号槽使用了额外的处理来实现，并不是 GoF 经典的观察者模式的实现方式。）<h3 id="6-1、信号和槽"><a href="#6-1、信号和槽" class="headerlink" title="6.1、信号和槽"></a>6.1、信号和槽</h3>信号与槽是通过connect（）函数连接起来的。<br>connect()函数最常用的一般形式：<blockquote>
<p>connect(sender, signal, receiver, slot);<br>为了体验一下信号槽的使用，我们以一段简单的代码说明：<br>参数：</p>
</blockquote>
</li>
<li>sender：发出信号的对象</li>
<li>signal：发送对象发出的信号</li>
<li>receiver：接收信号的对象</li>
<li>slot：接收对象在接收到信号之后所需要调用的函数。<br>信号槽要求信号和槽的参数一致，所谓一致，是参数类型一致。如果不一致，允许的情况是，槽函数的参数可以比信号的少，即便如此，槽函数存在的那些参数的顺序也必须和信号的前面几个一致起来。这是因为，你可以在槽函数中选择忽略信号传来的数据（也就是槽函数的参数比信号的少），但是不能说信号根本没有这个数据，你就要在槽函数中使用（就是槽函数的参数比信号的多，这是不允许的）。<br>需要注意的是：</li>
<li>Qt4 的书写方式：<blockquote>
<p>connect(button, SIGNAL(clicked()), &amp;a, SLOT(quit())); </p>
</blockquote>
</li>
<li>这里使用了SIGNAL和SLOT这两个宏，将两个函数名转换成了字符串。注意到connect()函数的 signal 和 slot 都是接受字符串，一旦出现连接不成功的情况，Qt4是没有编译错误的（因为一切都是字符串，编译期是不检查字符串是否匹配），而是在运行时给出错误。这无疑会增加程序的不稳定性。</li>
<li>Qt5在语法上完全兼容Qt4<h3 id="6-2、自定义信号槽"><a href="#6-2、自定义信号槽" class="headerlink" title="6.2、自定义信号槽"></a>6.2、自定义信号槽</h3>使用connect()可以让我们连接系统提供的信号和槽。但是，Qt 的信号槽机制并不仅仅是使用系统提供的那部分，还会允许我们自己设计自己的信号和槽。</li>
<li>只有继承了QObject类的类，才具有信号槽的能力。所以，为了使用信号槽，必须继承QObject。凡是QObject类（不管是直接子类还是间接子类），都应该在第一行代码写上Q_OBJECT。不管是不是使用信号槽，都应该添加这个宏。这个宏的展开将为我们的类提供信号槽机制、国际化机制以及 Qt 提供的不基于 C++ RTTI 的反射能力。</li>
<li>信号就是一个个的函数名，返回值是 void（因为无法获得信号的返回值，所以也就无需返回任何值），参数是该类需要让外界知道的数据。信号作为函数名，不需要在 cpp 函数中添加任何实现。</li>
<li>Qt 5 中，任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数。</li>
<li>与信号函数不同，槽函数必须自己完成实现代码。槽函数就是普通的成员函数，因此作为成员函数，也会受到 public、private 等访问控制符的影响。（如果信号是 private 的，这个信号就不能在类的外面连接，也就没有任何意义。）。<h3 id="6-3、自定义信号槽需要注意的事项"><a href="#6-3、自定义信号槽需要注意的事项" class="headerlink" title="6.3、自定义信号槽需要注意的事项"></a>6.3、自定义信号槽需要注意的事项</h3></li>
<li>发送者和接收者都需要是QObject的子类（当然，槽函数是全局函数、Lambda 表达式等无需接收者的时候除外）；</li>
<li>使用 signals 标记信号函数，信号是一个函数声明，返回 void，不需要实现函数代码；</li>
<li>槽函数是普通的成员函数，作为成员函数，会受到 public、private、protected 的影响；</li>
<li>使用 emit 在恰当的位置发送信号；</li>
<li>使用QObject::connect()函数连接信号和槽。</li>
<li>任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数<h3 id="6-4、信号槽的更多用法"><a href="#6-4、信号槽的更多用法" class="headerlink" title="6.4、信号槽的更多用法"></a>6.4、信号槽的更多用法</h3></li>
<li>一个信号可以和多个槽相连。<blockquote>
<p>如果是这种情况，这些槽会一个接一个的被调用，但是它们的调用顺序是不确定的。</p>
</blockquote>
</li>
<li>多个信号可以连接到一个槽.<blockquote>
<p>只要任意一个信号发出，这个槽就会被调用。</p>
</blockquote>
</li>
<li>一个信号可以连接到另外的一个信号。<blockquote>
<p>当第一个信号发出时，第二个信号被发出。除此之外，这种信号-信号的形式和信号-槽的形式没有什么区别。</p>
</blockquote>
</li>
<li>槽可以被取消链接。<blockquote>
<p>这种情况并不经常出现，因为当一个对象delete之后，Qt自动取消所有连接到这个对象上面的槽。</p>
</blockquote>
</li>
<li>使用Lambda 表达式。<br>在使用 Qt 5 的时候，能够支持 Qt 5 的编译器都是支持 Lambda 表达式的。<h3 id="6-5、Lambda表达式"><a href="#6-5、Lambda表达式" class="headerlink" title="6.5、Lambda表达式"></a>6.5、Lambda表达式</h3>C++11中的Lambda表达式用于定义并创建匿名的函数对象，以简化编程工作。首先看一下Lambda表达式的基本构成：<br><img src="https://gitee.com/kwb110/tuchuang/raw/master/009.png"><blockquote>
<p><a href="%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0">函数对象参数</a>mutable或exception -&gt;返回值{函数体}</p>
</blockquote>
</li>
<li>[]:标识一个Lambda的开始，这部分必须存在，不能省略。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。</li>
<li>数对象参数有以下形式：<blockquote>
<p>空:没有使用任何函数对象参数。<br>&#x3D;:函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。<br>&amp;:函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量）。<br>this:函数体内可以使用Lambda所在类中的成员变量。<br>a:将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。<br>&amp;a:将a按引用进行传递。<br>a, &amp;b:将a按值进行传递，b按引用进行传递。<br>&#x3D;，&amp;a, &amp;b:除a和b按引用进行传递外，其他参数都按值进行传递。<br>&amp;, a, b:除a和b按值进行传递外，其他参数都按引用进行传递。</p>
</blockquote>
</li>
<li>操作符重载函数参数:<blockquote>
<p>标识重载的()操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如：(a,b)）和按引用（如：(&amp;a,&amp;b)）两种方式进行传递。</p>
</blockquote>
</li>
<li>可修改标示符：<blockquote>
<p>mutable声明，这部分可以省略。按值传递函数对象参数时，加上mutable修饰符后，可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）。</p>
</blockquote>
</li>
<li>错误抛出标示符：<blockquote>
<p>exception声明，这部分也可以省略。exception声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用throw(int)。</p>
</blockquote>
</li>
<li>函数返回值：<blockquote>
<p>-&gt;返回值类型，标识函数返回值的类型，当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。</p>
</blockquote>
</li>
<li>是函数体：<blockquote>
<p>{}，标识函数的实现，这部分不能省略，但函数体可以为空。</p>
</blockquote>
<h1 id="7、坐标系统"><a href="#7、坐标系统" class="headerlink" title="7、坐标系统"></a>7、坐标系统</h1><h3 id="7-1、窗口坐标体系"><a href="#7-1、窗口坐标体系" class="headerlink" title="7.1、窗口坐标体系"></a>7.1、窗口坐标体系</h3><p>以左上角为原点，X向右增加，Y向下增加。对于嵌套窗口，其坐标是相对于父窗口来说的。</p>
<h3 id="7-2、QWidget"><a href="#7-2、QWidget" class="headerlink" title="7.2、QWidget"></a>7.2、QWidget</h3><p>所有窗口及窗口控件都是从QWidget直接或间接派生出来的。</p>
<h1 id="8、对象模型"><a href="#8、对象模型" class="headerlink" title="8、对象模型"></a>8、对象模型</h1><p>在Qt中创建对象的时候会提供一个Parent对象指针，下面来解释这个parent到底是干什么的。</p>
</li>
<li>1、QObject是以对象树的形式组织起来的。<blockquote>
<p>当你创建一个QObject对象时，会看到QObject的构造函数接收一个QObject指针作为参数，这个参数就是 parent，也就是父对象指针。<br>这相当于，在创建QObject对象时，可以提供一个其父对象，我们创建的这个QObject对象会自动添加到其父对象的children()列表。<br>当父对象析构的时候，这个列表中的所有对象也会被析构。（注意，这里的父对象并不是继承意义上的父类！）<br>这种机制在 GUI 程序设计中相当有用。例如，一个按钮有一个QShortcut（快捷键）对象作为其子对象。当我们删除按钮的时候，这个快捷键理应被删除。这是合理的。</p>
</blockquote>
</li>
<li>2、QWidget是能够在屏幕上显示的一切组件的父类。<blockquote>
<p>QWidget继承自QObject，因此也继承了这种对象树关系。一个孩子自动地成为父组件的一个子组件。因此，它会显示在父组件的坐标系统中，被父组件的边界剪裁。例如，当用户关闭一个对话框的时候，应用程序将其删除，那么，我们希望属于这个对话框的按钮、图标等应该一起被删除。事实就是如此，因为这些都是对话框的子组件。<br>当然，我们也可以自己删除子对象，它们会自动从其父对象列表中删除。比如，当我们删除了一个工具栏时，其所在的主窗口会自动将该工具栏从其子对象列表中删除，并且自动调整屏幕显示。</p>
</blockquote>
</li>
<li>3、Qt 引入对象树的概念，在一定程度上解决了内存问题。</li>
<li>4、当一个QObject对象在堆上创建的时候，Qt 会同时为其创建一个对象树。不过，对象树中对象的顺序是没有定义的。这意味着，销毁这些对象的顺序也是未定义的。</li>
<li>5、任何对象树中的 QObject对象 delete 的时候，如果这个对象有 parent，则自动将其从 parent 的children()列表中删除；如果有孩子，则自动 delete 每一个孩子。Qt 保证没有QObject会被 delete 两次，这是由析构顺序决定的。</li>
<li>6、如果QObject在栈上创建，Qt 保持同样的行为。正常情况下，这也不会发生什么问题。<h1 id="9、带菜单栏的窗口"><a href="#9、带菜单栏的窗口" class="headerlink" title="9、带菜单栏的窗口"></a>9、带菜单栏的窗口</h1><h3 id="9-1、菜单栏"><a href="#9-1、菜单栏" class="headerlink" title="9.1、菜单栏"></a>9.1、菜单栏</h3>一个主窗口最多只有一个菜单栏。位于主窗口顶部、主窗口标题栏下面。</li>
<li>创建菜单栏，通过QMainWindow类的menubar（）函数获取主窗口菜单栏指针<br>QMenuBar *    menuBar() const</li>
<li>创建菜单，调用QMenu的成员函数addMenu来添加菜单<br>QAction* addMenu(QMenu * menu)<br>QMenu* addMenu(const QString &amp; title)<br>QMenu* addMenu(const QIcon &amp; icon, const QString &amp; title)</li>
<li>创建菜单项，调用QMenu的成员函数addAction来添加菜单项<br>QAction* activeAction() const<br>QAction* addAction(const QString &amp; text)<br>QAction* addAction(const QIcon &amp; icon, const QString &amp; text)<br>QAction* addAction(const QString &amp; text, const QObject * receiver,<br>const char * member, const QKeySequence &amp; shortcut &#x3D; 0)<br>QAction* addAction(const QIcon &amp; icon, const QString &amp; text, const QObject * receiver, const char * member,<br>const QKeySequence &amp; shortcut &#x3D; 0)</li>
<li>Qt 并没有专门的菜单项类，只是使用一个QAction类，抽象出公共的动作。当我们把QAction对象添加到菜单，就显示成一个菜单项，添加到工具栏，就显示成一个工具按钮。用户可以通过点击菜单项、点击工具栏按钮、点击快捷键来激活这个动作。<h3 id="9-2、工具栏"><a href="#9-2、工具栏" class="headerlink" title="9.2、工具栏"></a>9.2、工具栏</h3>主窗口的工具栏上可以有多个工具条，通常采用一个菜单对应一个工具条的的方式，也可根据需要进行工具条的划分。</li>
<li>直接调用QMainWindow类的addToolBar（）函数获取主窗口的工具条对象，每增加一个工具条都需要调用一次该函数。</li>
<li>插入属于工具条的动作，即在工具条上添加操作。<br>通过QToolBar类的addAction函数添加。</li>
<li>工具条是一个可移动的窗口，它的停靠区域由QToolBar的allowAreas决定，包括：</li>
<li>Qt::LeftToolBarArea        停靠在左侧</li>
<li>Qt::RightToolBarArea        停靠在右侧</li>
<li>Qt::TopToolBarArea        停靠在顶部</li>
<li>Qt::BottomToolBarArea       停靠在底部</li>
<li>Qt::AllToolBarAreas        以上四个位置都可停靠<br>使用setAllowedAreas（）函数指定停靠区域：<br>setAllowedAreas（Qt::LeftToolBarArea | Qt::RightToolBarArea）<br>使用setMoveable（）函数设定工具栏的可移动性：<br>setMoveable（false）&#x2F;&#x2F;工具条不可移动, 只能停靠在初始化的位置上<h3 id="9-3、状态栏"><a href="#9-3、状态栏" class="headerlink" title="9.3、状态栏"></a>9.3、状态栏</h3>派生自QWidget类，使用方法与QWidget类似，QStatusBar类常用成员函数：<br>&#x2F;&#x2F;添加小部件<br>void addWidget(QWidget * widget, int stretch &#x3D; 0)<br>&#x2F;&#x2F;插入小部件<br>int    insertWidget(int index, QWidget * widget, int stretch &#x3D; 0)<br>&#x2F;&#x2F;删除小部件<br>void removeWidget(QWidget * widget)<h3 id="9-4、资源文件"><a href="#9-4、资源文件" class="headerlink" title="9.4、资源文件"></a>9.4、资源文件</h3></li>
<li>Qt 资源系统是一个跨平台的资源机制，用于将程序运行时所需要的资源以二进制的形式存储于可执行文件内部。如果你的程序需要加载特定的资源（图标、文本翻译等），那么，将其放置在资源文件中，就再也不需要担心这些文件的丢失。也就是说，如果你将资源以资源文件形式存储，它是会编译到可执行文件内部。<br>使用 Qt Creator 可以很方便地创建资源文件。我们可以在工程上点右键，选择“添加新文件…”，可以在 Qt 分类下找到“Qt 资源文件”。</li>
<li>点击“选择…”按钮，打开“新建 Qt 资源文件”对话框。在这里我们输入资源文件的名字和路径。</li>
<li>点击下一步，选择所需要的版本控制系统，然后直接选择完成。我们可以在 Qt Creator 的左侧文件列表中看到“资源文件”一项，也就是我们新创建的资源文件。</li>
<li>右侧的编辑区有个“添加”，我们首先需要添加前缀，比如我们将前缀取名为 images。然后选中这个前缀，继续点击添加文件，可以找到我们所需添加的文件。这里，我们选择 document-open.png 文件。当我们完成操作之后，Qt Creator 应该是这样子的。</li>
<li>接下来，我们还可以添加另外的前缀或者另外的文件。这取决于你的需要。当我们添加完成之后，我们可以像前面一章讲解的那样，通过使用 : 开头的路径来找到这个文件。比如，我们的前缀是 &#x2F;images，文件是 document-open.png，那么就可以使用:&#x2F;images&#x2F;document-open.png找到这个文件。<br>这么做带来的一个问题是，如果以后我们要更改文件名，比如将 docuemnt-open.png 改成 docopen.png，那么，所有使用了这个名字的路径都需要修改。所以，更好的办法是，我们给这个文件去一个“别名”，以后就以这个别名来引用这个文件。具体做法是，选中这个文件，添加别名信息。</li>
<li>这样，我们可以直接使用:&#x2F;images&#x2F;doc-open引用到这个资源，无需关心图片的真实文件名。<h1 id="10、对话框"><a href="#10、对话框" class="headerlink" title="10、对话框"></a>10、对话框</h1>对话框是 GUI 程序中不可或缺的组成部分。很多不能或者不适合放入主窗口的功能组件都必须放在对话框中设置。对话框通常会是一个顶层窗口，出现在程序最上层，用于实现短期任务或者简洁的用户交互。<br>Qt 中使用QDialog类实现对话框。就像主窗口一样，我们通常会设计一个类继承QDialog。QDialog（及其子类，以及所有Qt::Dialog类型的类）的对于其 parent 指针都有额外的解释：如果 parent 为 NULL，则该对话框会作为一个顶层窗口，否则则作为其父组件的子对话框（此时，其默认出现的位置是 parent 的中心）。顶层窗口与非顶层窗口的区别在于，顶层窗口在任务栏会有自己的位置，而非顶层窗口则会共享其父组件的位置。<h3 id="10-1、对话框分为模态对话框和非模态对话框。"><a href="#10-1、对话框分为模态对话框和非模态对话框。" class="headerlink" title="10.1、对话框分为模态对话框和非模态对话框。"></a>10.1、对话框分为模态对话框和非模态对话框。</h3><blockquote>
<p>模态对话框，就是会阻塞同一应用程序中其它窗口的输入。<br>模态对话框很常见，比如“打开文件”功能。你可以尝试一下记事本的打开文件，当打开文件对话框出现时，我们是不能对除此对话框之外的窗口部分进行操作的。<br>与此相反的是非模态对话框，例如查找对话框，我们可以在显示着查找对话框的同时，继续对记事本的内容进行编辑。</p>
</blockquote>
<h3 id="10-2、标准对话框"><a href="#10-2、标准对话框" class="headerlink" title="10.2、标准对话框"></a>10.2、标准对话框</h3><p>所谓标准对话框，是 Qt 内置的一系列对话框，用于简化开发。事实上，有很多对话框都是通用的，比如打开文件、设置颜色、打印设置等。这些对话框在所有程序中几乎相同，因此没有必要在每一个程序中都自己实现这么一个对话框。<br>Qt 的内置对话框大致分为以下几类：</p>
</li>
<li>QColorDialog：        选择颜色；</li>
<li>QFileDialog：            选择文件或者目录；</li>
<li>QFontDialog：            选择字体；</li>
<li>QInputDialog：        允许用户输入一个值，并将其值返回；</li>
<li>QMessageBox：            模态对话框，用于显示信息、询问问题等；</li>
<li>QPageSetupDialog：    为打印机提供纸张相关的选项；</li>
<li>QPrintDialog：        打印机配置；</li>
<li>QPrintPreviewDialog：打印预览；</li>
<li>QProgressDialog：        显示操作过程。<h3 id="10-3、自定义消息框"><a href="#10-3、自定义消息框" class="headerlink" title="10.3、自定义消息框"></a>10.3、自定义消息框</h3>Qt 支持模态对话框和非模态对话框。<br>模态与非模态的实现：</li>
<li>使用QDialog::exec()实现应用程序级别的模态对话框</li>
<li>使用QDialog::open()实现窗口级别的模态对话框</li>
<li>使用QDialog::show()实现非模态对话框。<h3 id="10-4、模态对话框"><a href="#10-4、模态对话框" class="headerlink" title="10.4、模态对话框"></a>10.4、模态对话框</h3></li>
<li>有两种级别的模态对话框：<blockquote>
<p>应用程序级别的模态<br>当该种模态的对话框出现时，用户必须首先对对话框进行交互，直到关闭对话框，然后才能访问程序中其他的窗口。<br>窗口级别的模态<br>该模态仅仅阻塞与对话框关联的窗口，但是依然允许用户与程序中其它窗口交互。窗口级别的模态尤其适用于多窗口模式。</p>
</blockquote>
</li>
<li>一般默认是应用程序级别的模态。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小K</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/03/29/QtStudy/01day/">http://example.com/2022/03/29/QtStudy/01day/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">CodeingKang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Qt/">Qt</a></div><div class="post_share"><div class="social-share" data-image="/./img/Qt%E5%B0%81%E9%9D%A2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2022/03/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BB%AA%E8%AE%BA/"><img class="prev-cover" src="/./img/bofengfuyong.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机网络绪论</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/03/30/QtStudy/01day_1/" title="Qt窗口系统"><img class="cover" src="/./img/Qt%E5%B0%81%E9%9D%A2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-30</div><div class="title">Qt窗口系统</div></div></a></div><div><a href="/2022/04/01/QtStudy/02day/" title="控件，样式表与事件"><img class="cover" src="/./img/Qt%E5%B0%81%E9%9D%A2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-01</div><div class="title">控件，样式表与事件</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">小k</div><div class="author-info__description">一只it蛙的练功房</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><a id="card-info-btn"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/kangWENBIN/kangWENBIN.github.io" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1961980295@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临，上座，请喝茶^V^</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81Qt%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">1、Qt的介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E3%80%81-%E4%BB%80%E4%B9%88%E6%98%AFQt"><span class="toc-number">1.0.1.</span> <span class="toc-text">1.1、 什么是Qt?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E3%80%81Qt%E5%8E%86%E5%8F%B2"><span class="toc-number">1.0.2.</span> <span class="toc-text">1.2、Qt历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%E3%80%81%E6%94%AF%E6%8C%81%E5%B9%B3%E5%8F%B0"><span class="toc-number">1.0.3.</span> <span class="toc-text">1.3、支持平台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4%E3%80%81Qt%E7%89%88%E6%9C%AC"><span class="toc-number">1.0.4.</span> <span class="toc-text">1.4、Qt版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5%E3%80%81Qt%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.0.5.</span> <span class="toc-text">1.5、Qt的优点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81Qt%E7%9A%84%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.</span> <span class="toc-text">2、Qt的安装步骤</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">3、项目文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E3%80%81%E4%BD%BF%E7%94%A8%E5%90%91%E5%AF%BC%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-number">3.0.1.</span> <span class="toc-text">3.1、使用向导创建项目</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAQt%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.</span> <span class="toc-text">4、第一个Qt程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E3%80%81%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84Qt%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.0.1.</span> <span class="toc-text">4.1、一个最简单的Qt应用程序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E3%80%81%E7%AA%97%E5%8F%A3%EF%BC%88%E6%8E%A7%E4%BB%B6%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">5、窗口（控件）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E3%80%81QPushButtn"><span class="toc-number">5.0.1.</span> <span class="toc-text">5.1、QPushButtn</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E3%80%81%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD"><span class="toc-number">6.</span> <span class="toc-text">6、信号和槽</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1%E3%80%81%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD"><span class="toc-number">6.0.1.</span> <span class="toc-text">6.1、信号和槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%A1%E5%8F%B7%E6%A7%BD"><span class="toc-number">6.0.2.</span> <span class="toc-text">6.2、自定义信号槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%A1%E5%8F%B7%E6%A7%BD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B%E9%A1%B9"><span class="toc-number">6.0.3.</span> <span class="toc-text">6.3、自定义信号槽需要注意的事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4%E3%80%81%E4%BF%A1%E5%8F%B7%E6%A7%BD%E7%9A%84%E6%9B%B4%E5%A4%9A%E7%94%A8%E6%B3%95"><span class="toc-number">6.0.4.</span> <span class="toc-text">6.4、信号槽的更多用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5%E3%80%81Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">6.0.5.</span> <span class="toc-text">6.5、Lambda表达式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E3%80%81%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F"><span class="toc-number">7.</span> <span class="toc-text">7、坐标系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1%E3%80%81%E7%AA%97%E5%8F%A3%E5%9D%90%E6%A0%87%E4%BD%93%E7%B3%BB"><span class="toc-number">7.0.1.</span> <span class="toc-text">7.1、窗口坐标体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2%E3%80%81QWidget"><span class="toc-number">7.0.2.</span> <span class="toc-text">7.2、QWidget</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E3%80%81%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">8.</span> <span class="toc-text">8、对象模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9%E3%80%81%E5%B8%A6%E8%8F%9C%E5%8D%95%E6%A0%8F%E7%9A%84%E7%AA%97%E5%8F%A3"><span class="toc-number">9.</span> <span class="toc-text">9、带菜单栏的窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1%E3%80%81%E8%8F%9C%E5%8D%95%E6%A0%8F"><span class="toc-number">9.0.1.</span> <span class="toc-text">9.1、菜单栏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2%E3%80%81%E5%B7%A5%E5%85%B7%E6%A0%8F"><span class="toc-number">9.0.2.</span> <span class="toc-text">9.2、工具栏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3%E3%80%81%E7%8A%B6%E6%80%81%E6%A0%8F"><span class="toc-number">9.0.3.</span> <span class="toc-text">9.3、状态栏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4%E3%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">9.0.4.</span> <span class="toc-text">9.4、资源文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10%E3%80%81%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">10.</span> <span class="toc-text">10、对话框</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1%E3%80%81%E5%AF%B9%E8%AF%9D%E6%A1%86%E5%88%86%E4%B8%BA%E6%A8%A1%E6%80%81%E5%AF%B9%E8%AF%9D%E6%A1%86%E5%92%8C%E9%9D%9E%E6%A8%A1%E6%80%81%E5%AF%B9%E8%AF%9D%E6%A1%86%E3%80%82"><span class="toc-number">10.0.1.</span> <span class="toc-text">10.1、对话框分为模态对话框和非模态对话框。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2%E3%80%81%E6%A0%87%E5%87%86%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">10.0.2.</span> <span class="toc-text">10.2、标准对话框</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF%E6%A1%86"><span class="toc-number">10.0.3.</span> <span class="toc-text">10.3、自定义消息框</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4%E3%80%81%E6%A8%A1%E6%80%81%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">10.0.4.</span> <span class="toc-text">10.4、模态对话框</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/11/Linux/%E7%BA%BF%E7%A8%8B%E6%B1%A0_C/" title="无题"><img src="https://picsum.photos/536/354" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/04/11/Linux/%E7%BA%BF%E7%A8%8B%E6%B1%A0_C/" title="无题">无题</a><time datetime="2022-04-11T13:23:53.077Z" title="发表于 2022-04-11 21:23:53">2022-04-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/01/QtStudy/02day/" title="控件，样式表与事件"><img src="/./img/Qt%E5%B0%81%E9%9D%A2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="控件，样式表与事件"/></a><div class="content"><a class="title" href="/2022/04/01/QtStudy/02day/" title="控件，样式表与事件">控件，样式表与事件</a><time datetime="2022-04-01T02:00:00.000Z" title="发表于 2022-04-01 10:00:00">2022-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/30/QtStudy/01day_1/" title="Qt窗口系统"><img src="/./img/Qt%E5%B0%81%E9%9D%A2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Qt窗口系统"/></a><div class="content"><a class="title" href="/2022/03/30/QtStudy/01day_1/" title="Qt窗口系统">Qt窗口系统</a><time datetime="2022-03-30T02:00:00.000Z" title="发表于 2022-03-30 10:00:00">2022-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/29/CPP/%E5%A4%9A%E6%80%81/" title="C++之多态性"><img src="/./img/%E5%A4%9A%E6%80%81%E5%B0%81%E9%9D%A2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++之多态性"/></a><div class="content"><a class="title" href="/2022/03/29/CPP/%E5%A4%9A%E6%80%81/" title="C++之多态性">C++之多态性</a><time datetime="2022-03-29T02:00:00.000Z" title="发表于 2022-03-29 10:00:00">2022-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/29/CPP/%E6%8F%90%E7%BA%B2/" title="C++基本框架复习"><img src="/./img/C++%E5%B0%81%E9%9D%A2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++基本框架复习"/></a><div class="content"><a class="title" href="/2022/03/29/CPP/%E6%8F%90%E7%BA%B2/" title="C++基本框架复习">C++基本框架复习</a><time datetime="2022-03-29T02:00:00.000Z" title="发表于 2022-03-29 10:00:00">2022-03-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/./img/Qt%E5%B0%81%E9%9D%A2.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 小k</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">很高兴认识你</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>